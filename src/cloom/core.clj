(ns cloom.core)

(def bytes-per-thing 10)
(def bytes-per-linedef 14)
(def bytes-per-sidedef 30)
(def bytes-per-vertex 4)
(def bytes-per-sector 26)

(defn hexify [x]
  "Convert a 0-255 number to hexadecimal, msb first."
  (let [letters [\0 \1 \2 \3 \4 \5 \6 \7 \8 \9 \a \b \c \d \e \f]
        msb (nth letters (int (/ x 16)))
        lsb (nth letters (rem x 16))
        ]
    (str msb lsb)))

(defn decify [x]
  "Convert a two character list of hexadecimals (msb first) to a single int."
  (let [letters [\0 \1 \2 \3 \4 \5 \6 \7 \8 \9 \a \b \c \d \e \f]
        values (apply hash-map (interleave letters (range 16)))
        msb (values (first x))
        lsb (values (nth x 1))
        ]
    (+ (* msb 16) lsb)))

(defn to-int32 [x]
  "Return as four bytes, lsb first."
  (map #(rem (bit-shift-right x (* % 8)) 256) (range 4)))

(defn from-int32 [bs]
  "Take list of four ints (lsb first) and turn into a single int."
  (reduce + (map #(bit-shift-left (nth bs %) (* 8 %)) (range 4))))

(defn from-int16 [bs]
  "Take list of four ints (lsb first) and turn into a single int."
  (reduce + (map #(bit-shift-left (nth bs %) (* 8 %)) (range 2))))

(defn to-int16 [x]
  "Return as four bytes, lsb first."
  (map #(rem (bit-shift-right x (* % 8)) 256) (range 2)))

(defn clean-hexstring [hs]
  "Return hexstring with all spaces, newlines, and [^0-9a-f] removed."
  (filter #(#{\0 \1 \2 \3 \4 \5 \6 \7 \8 \9 \a \b \c \d \e \f} %) hs))

(defn string-to-padded-ints [s]
 "Convert a string to 8 ints zero-padded."
 (concat (map int s)
         (for [i (range (- 8 (count s)))] 0)))

(defn hexstring-to-ints [hexstring]
  "Read a hexdump (generated by xxd -p) and return a list of ints."
  (let [
        hs (clean-hexstring hexstring)
        hexbytes (map #(take 2 (drop % hs)) (range 0 (count hs) 2))
        ]
    (map decify hexbytes)))

(defn ints-to-hexstring [byte-ints]
  "Convert a list of ints into a hexadecimal string."
  (apply str (map hexify byte-ints)))

(defn read-header [hexstring]
  "Reads the header from the wad as a list of ints."
  (let [hs (clean-hexstring (take 32 hexstring))
        wad-ints (hexstring-to-ints hs)
        id (apply str (map char (take 4 wad-ints)))
        num-lumps (from-int32 (take 4 (drop 4 wad-ints)))
        info-table-offset (from-int32 (take 4 (drop 8 wad-ints)))
        ;dummy (println (str "id: " id))
        ]
    {:id id
     :num-lumps num-lumps
     :info-table-offset info-table-offset
     }))

(defn read-directory [hexstring header]
  "Reads the directory, given the offset and the wad-ints."
  (let [offset (* (:info-table-offset header) 2)
        num-lumps (:num-lumps header)
        hs (clean-hexstring hexstring)
        directory-hexstring (drop offset hs)
        directory-ints (hexstring-to-ints directory-hexstring)
        ]
    (for [lump (range num-lumps)]
      (let [i (* lump 16)
            lump-offset (from-int32 (take 4 (drop i directory-ints)))
            lump-size (from-int32 (take 4 (drop (+ 4 i) directory-ints)))
            lump-name (apply str (map char (take 8 (drop (+ 8 i) directory-ints))))
            ]
        {:offset lump-offset
         :size lump-size
         :name lump-name}))))

(defn read-thing [thing-ints]
  "Reads a 10 byte (in int format) thing."
  (let [x-position (from-int16 (take 2 thing-ints))
        y-position (from-int16 (take 2 (drop 2 thing-ints)))
        angle-facing (from-int16 (take 2 (drop 4 thing-ints)))
        thing-type (from-int16 (take 2 (drop 6 thing-ints)))
        flags (from-int16 (take 2 (drop 8 thing-ints)))
        ]
    {:x-position x-position
     :y-position y-position
     :angle-facing angle-facing
     :thing-type thing-type
     :flags flags
     }))

(defn read-linedef [linedef-ints]
  "Reads a 14 byte (in int format) linedef."
  (let [start-vertex (from-int16 (take 2 linedef-ints))
        end-vertex (from-int16 (take 2 (drop 2 linedef-ints)))
        flags (from-int16 (take 2 (drop 4 linedef-ints)))
        special-type (from-int16 (take 2 (drop 6 linedef-ints)))
        sector-tag (from-int16 (take 2 (drop 8 linedef-ints)))
        front-sidedef (from-int16 (take 2 (drop 10 linedef-ints)))
        back-sidedef (from-int16 (take 2 (drop 12 linedef-ints)))
        ]
    {:start-vertex start-vertex
     :end-vertex end-vertex
     :flags flags
     :special-type special-type
     :sector-tag sector-tag
     :front-sidedef front-sidedef
     :back-sidedef back-sidedef
     }))

(defn read-sidedef [sidedef-ints]
  "Reads a 30 byte (in int format) sidedef."
  (let [x-offset (from-int16 (take 2 sidedef-ints))
        y-offset (from-int16 (take 2 (drop 2 sidedef-ints)))
        upper-texture-name (re-find #"^[A-Za-z0-9-]*" (apply str (map char (take 8 (drop 4 sidedef-ints)))))
        lower-texture-name (re-find #"^[A-Za-z0-9-]*" (apply str (map char (take 8 (drop 12 sidedef-ints)))))
        middle-texture-name (re-find #"^[A-Za-z0-9-]*" (apply str (map char (take 8 (drop 20 sidedef-ints)))))
        sector-number (from-int16 (take 2 (drop 28 sidedef-ints)))
        ]
    {:x-offset x-offset
     :y-offset y-offset
     :upper-texture-name upper-texture-name
     :lower-texture-name lower-texture-name
     :middle-texture-name middle-texture-name
     :sector-number sector-number
     }))

(defn read-vertex [vertex-ints]
  "Reads a 4 byte (in int format) vertex."
  (let [x-position (from-int16 (take 2 vertex-ints))
        y-position (from-int16 (take 2 (drop 2 vertex-ints)))
        ]
    {:x-position x-position
     :y-position y-position
     }))

(defn read-sector [sector-ints]
  "Reads a 26 byte (in int format) sector."
  (let [floor-height (from-int16 (take 2 sector-ints))
        ceiling-height (from-int16 (take 2 (drop 2 sector-ints)))
        floor-texture-name (re-find #"^[A-Za-z0-9-]*" (apply str (map char (take 8 (drop 4 sector-ints)))))
        ceiling-texture-name (re-find #"^[A-Za-z0-9-]*" (apply str (map char (take 8 (drop 12 sector-ints)))))
        light-level (from-int16 (take 2 (drop 20 sector-ints)))
        sector-type (from-int16 (take 2 (drop 22 sector-ints)))
        tag-number (from-int16 (take 2 (drop 24 sector-ints)))
        ]
    {:floor-height floor-height
     :ceiling-height ceiling-height
     :floor-texture-name floor-texture-name
     :ceiling-texture-name ceiling-texture-name
     :light-level light-level
     :sector-type sector-type
     :tag-number tag-number
     }))

(defn parse-entries
  "Read a lump with a given reader function, whose entries are entry-size long."
  ([reader entry-size lump-ints] (parse-entries reader entry-size lump-ints (list )))
  ([reader entry-size lump-ints entries]
   (if (empty? lump-ints)
     entries
     (recur reader
            entry-size
            (drop entry-size lump-ints)
            (concat entries (list (reader lump-ints)))))))


(defn read-lump [hexstring directory-entry]
  "Reads the hexstring for a lump given a directory entry."
  (let [hs (take (* 2 (:size directory-entry))
                 (drop (* 2 (:offset directory-entry)) (clean-hexstring hexstring)))
        lump-ints (hexstring-to-ints hs)
        lump-name (re-find #"^[A-Z0-9]*" (:name directory-entry))
        ]
    (case lump-name
      "THINGS" (parse-entries read-thing bytes-per-thing lump-ints)
      "LINEDEFS" (parse-entries read-linedef bytes-per-linedef lump-ints)
      "SIDEDEFS" (parse-entries read-sidedef bytes-per-sidedef lump-ints)
      "VERTEXES" (parse-entries read-vertex bytes-per-vertex lump-ints)
      "SEGS" "SEGS not implemented."
      "SSECTORS" "SSECTORS not implemented."
      "NODES" "NODES not implemented."
      "SECTORS" (parse-entries read-sector bytes-per-sector lump-ints)
      "REJECT" "REJECT not implemented."
      "BLOCKMAP" "BLOCKMAP not implemented."
      "BEHAVIOR" "BEHAVIOR not implemented."
      (str "Unrecognized lump type: " lump-name)
      )
    ))

; write functions

(defn things-to-ints [things]
  "Take a list of things and turn them into a list of ints representing each byte in file."
  (let [f (fn [thing]
            (concat
              (to-int16 (:x-position thing))
              (to-int16 (:y-position thing))
              (to-int16 (:angle-facing thing))
              (to-int16 (:thing-type thing))
              (to-int16 (:flags thing))))
        ]
    (apply concat (map f things))))

(defn linedefs-to-ints [linedefs]
  "Take a list of linedefs and turn them into a list of ints representing each byte in file."
  (let [f (fn [linedef]
            (concat
              (to-int16 (:start-vertex linedef))
              (to-int16 (:end-vertex linedef))
              (to-int16 (:flags linedef))
              (to-int16 (:special-type linedef))
              (to-int16 (:sector-tag linedef))
              (to-int16 (:front-sidedef linedef))
              (to-int16 (:back-sidedef linedef))))
        ]
    (apply concat (map f linedefs))))

(defn sidedefs-to-ints [sidedefs]
  "Take a list of sidedefs and turn them into a list of ints representing each byte in file."
  (let [f (fn [sidedef]
            (concat
              (to-int16 (:x-offset sidedef))
              (to-int16 (:y-offset sidedef))
              (string-to-padded-ints (:upper-texture-name sidedef))
              (string-to-padded-ints (:lower-texture-name sidedef))
              (string-to-padded-ints (:middle-texture-name sidedef))
              (to-int16 (:sector-number sidedef))))
        ]
    (apply concat (map f sidedefs))))

(defn vertexes-to-ints [vertexes]
  "Take a list of vertexes and turn them into a list of ints representing each byte in file."
  (let [f (fn [vertex]
            (concat
              (to-int16 (:x-position vertex))
              (to-int16 (:y-position vertex))))
        ]
    (apply concat (map f vertexes))))

(defn sectors-to-ints [sectors]
  "Take a list of sectors and turn them into a list of ints representing each byte in file."
  (let [f (fn [sector]
            (concat
              (to-int16 (:floor-height sector))
              (to-int16 (:ceiling-height sector))
              (string-to-padded-ints (:floor-texture-name sector))
              (string-to-padded-ints (:ceiling-texture-name sector))
              (to-int16 (:light-level sector))
              (to-int16 (:sector-type sector))
              (to-int16 (:tag-number sector))))
        ]
    (apply concat (map f sectors))))

(defn map-to-wad-hexstring
  "Convert a map to hexstring of a wad file."
  [map-name things linedefs sidedefs vertexes sectors]
  (let [thing-ints (things-to-ints things)
        linedef-ints (linedefs-to-ints linedefs)
        sidedef-ints (sidedefs-to-ints sidedefs)
        vertex-ints (vertexes-to-ints vertexes)
        sector-ints (sectors-to-ints sectors)
        header-size 12
        num-lumps 6 ; includes nodebuilt lumps (6), above lumps (5), map name (1)
        map-start header-size
        things-start header-size
        linedefs-start (+ things-start (count thing-ints))
        sidedefs-start (+ linedefs-start (count linedef-ints))
        vertexes-start (+ sidedefs-start (count sidedef-ints))
        sectors-start (+ vertexes-start (count vertex-ints))
        directory-start (+ sectors-start (count sector-ints))
        directory-ints (concat (to-int32 map-start) (to-int32 0) (string-to-padded-ints "MAP01")
                               (to-int32 things-start) (to-int32 (count thing-ints)) (string-to-padded-ints "THINGS")
                               (to-int32 linedefs-start) (to-int32 (count linedef-ints)) (string-to-padded-ints "LINEDEFS")
                               (to-int32 sidedefs-start) (to-int32 (count sidedef-ints)) (string-to-padded-ints "SIDEDEFS")
                               (to-int32 vertexes-start) (to-int32 (count vertex-ints)) (string-to-padded-ints "VERTEXES")
                               (to-int32 sectors-start) (to-int32 (count sector-ints)) (string-to-padded-ints "SECTORS")
                               )
        header-ints (concat (map int "PWAD")
                            (to-int32 num-lumps)
                            (to-int32 directory-start))
        dummy (println (str "map-start:  " map-start
                            "\nthings-start:  " things-start
                            "\nlinedefs-start:  " linedefs-start
                            "\nsidedefs-start:  " sidedefs-start
                            "\nvertexes-start:  " vertexes-start
                            "\nsectors-start:  " sectors-start
                            "\ndirectory-start:  " directory-start
                            "\ndirectory-ints:\n" directory-ints))
        ]
    (ints-to-hexstring (concat header-ints thing-ints linedef-ints sidedef-ints vertex-ints sector-ints directory-ints))
    ))


