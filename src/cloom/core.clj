(ns cloom.core)

(defn hexify [x]
  "Convert a 0-255 number to hexadecimal, msb first."
  (let [letters [\0 \1 \2 \3 \4 \5 \6 \7 \8 \9 \a \b \c \d \e \f]
        msb (nth letters (int (/ x 16)))
        lsb (nth letters (rem x 16))
        ]
    (str msb lsb)))

(defn decify [x]
  "Convert a two character list of hexadecimals (msb first) to a single int."
  (let [letters [\0 \1 \2 \3 \4 \5 \6 \7 \8 \9 \a \b \c \d \e \f]
        values (apply hash-map (interleave letters (range 16)))
        msb (values (first x))
        lsb (values (nth x 1))
        ]
    (+ (* msb 16) lsb)))

(defn to-int32 [x]
  "Return as four bytes, lsb first."
  (map #(rem (bit-shift-right x (* % 8)) 256) (range 4)))

(defn from-int32 [bs]
  "Take list of four ints (lsb first) and turn into a single int."
  (reduce + (map #(bit-shift-left (nth bs %) (* 8 %)) (range 4))))

(defn from-int16 [bs]
  "Take list of four ints (lsb first) and turn into a single int."
  (reduce + (map #(bit-shift-left (nth bs %) (* 8 %)) (range 2))))

(defn clean-hexstring [hs]
  "Return hexstring with all spaces, newlines, and [^0-9a-f] removed."
  (filter #(#{\0 \1 \2 \3 \4 \5 \6 \7 \8 \9 \a \b \c \d \e \f} %) hs))

(defn hexstring-to-ints [hexstring]
  "Read a hexdump (generated by xxd -p) and return a list of ints."
  (let [
        hs (clean-hexstring hexstring)
        hexbytes (map #(take 2 (drop % hs)) (range 0 (count hs) 2))
        ]
    (map decify hexbytes)))

(defn read-header [hexstring]
  "Reads the header from the wad as a list of ints."
  (let [hs (clean-hexstring (take 32 hexstring))
        wad-ints (hexstring-to-ints hs)
        id (apply str (map char (take 4 wad-ints)))
        num-lumps (from-int32 (take 4 (drop 4 wad-ints)))
        info-table-offset (from-int32 (take 4 (drop 8 wad-ints)))
        dummy (println (str "id: " id))
        ]
    {:id id
     :num-lumps num-lumps
     :info-table-offset info-table-offset
     }))

(defn read-directory [hexstring header]
  "Reads the directory, given the offset and the wad-ints."
  (let [offset (* (:info-table-offset header) 2)
        num-lumps (:num-lumps header)
        hs (clean-hexstring hexstring)
        directory-hexstring (drop offset hs)
        directory-ints (hexstring-to-ints directory-hexstring)
        ]
    (for [lump (range num-lumps)]
      (let [i (* lump 16)
            lump-offset (from-int32 (take 4 (drop i directory-ints)))
            lump-size (from-int32 (take 4 (drop (+ 4 i) directory-ints)))
            lump-name (apply str (map char (take 8 (drop (+ 8 i) directory-ints))))
            ]
        {:offset lump-offset
         :size lump-size
         :name lump-name}))))

(defn read-thing [thing-ints]
  "Reads a 10 byte (in int format) thing."
  (let [x-position (from-int16 (take 2 thing-ints))
        y-position (from-int16 (take 2 (drop 2 thing-ints)))
        angle-facing (from-int16 (take 2 (drop 4 thing-ints)))
        thing-type (from-int16 (take 2 (drop 6 thing-ints)))
        flags (from-int16 (take 2 (drop 8 thing-ints)))
        ]
    {:x-position x-position
     :y-position y-position
     :angle-facing angle-facing
     :thing-type thing-type
     :flags flags
     }))

(defn read-linedef [linedef-ints]
  "Reads a 14 byte (in int format) linedef."
  (let [start-vertex (from-int16 (take 2 linedef-ints))
        end-vertex (from-int16 (take 2 (drop 2 linedef-ints)))
        flags (from-int16 (take 2 (drop 4 linedef-ints)))
        special-type (from-int16 (take 2 (drop 6 linedef-ints)))
        sector-tag (from-int16 (take 2 (drop 8 linedef-ints)))
        front-sidedef (from-int16 (take 2 (drop 10 linedef-ints)))
        back-sidedef (from-int16 (take 2 (drop 12 linedef-ints)))
        ]
    {:start-vertex start-vertex
     :end-vertex end-vertex
     :flags flags
     :special-type special-type
     :sector-tag sector-tag
     :front-sidedef front-sidedef
     :back-sidedef back-sidedef
     }))

(defn read-sidedef [sidedef-ints]
  "Reads a 30 byte (in int format) sidedef."
  (let [x-offset (from-int16 (take 2 sidedef-ints))
        y-offset (from-int16 (take 2 (drop 2 sidedef-ints)))
        upper-texture-name (re-find #"^[A-Za-z0-9-]*" (apply str (map char (take 8 (drop 4 sidedef-ints)))))
        lower-texture-name (re-find #"^[A-Za-z0-9-]*" (apply str (map char (take 8 (drop 12 sidedef-ints)))))
        middle-texture-name (re-find #"^[A-Za-z0-9-]*" (apply str (map char (take 8 (drop 20 sidedef-ints)))))
        sector-number (from-int16 (take 2 (drop 28 sidedef-ints)))
        ]
    {:x-offset x-offset
     :y-offset y-offset
     :upper-texture-name upper-texture-name
     :lower-texture-name lower-texture-name
     :middle-texture-name middle-texture-name
     :sector-number sector-number
     }))

(defn read-vertex [vertex-ints]
  "Reads a 4 byte (in int format) vertex."
  (let [x-position (from-int16 (take 2 vertex-ints))
        y-position (from-int16 (take 2 (drop 2 vertex-ints)))
        ]
    {:x-position x-position
     :y-position y-position
     }))

(defn read-sector [sector-ints]
  "Reads a 26 byte (in int format) sector."
  (let [floor-height (from-int16 (take 2 sector-ints))
        ceiling-height (from-int16 (take 2 (drop 2 sector-ints)))
        floor-texture-name (re-find #"^[A-Za-z0-9-]*" (apply str (map char (take 8 (drop 4 sector-ints)))))
        ceiling-texture-name (re-find #"^[A-Za-z0-9-]*" (apply str (map char (take 8 (drop 12 sector-ints)))))
        light-level (from-int16 (take 2 (drop 20 sector-ints)))
        sector-type (from-int16 (take 2 (drop 22 sector-ints)))
        tag-number (from-int16 (take 2 (drop 24 sector-ints)))
        ]
    {:floor-height floor-height
     :ceiling-height ceiling-height
     :floor-texture-name floor-texture-name
     :ceiling-texture-name ceiling-texture-name
     :light-level light-level
     :sector-type sector-type
     :tag-number tag-number
     }))

(defn parse-entries
  "Read a lump with a given reader function, whose entries are entry-size long."
  ([reader entry-size lump-ints] (parse-entries reader entry-size lump-ints (list )))
  ([reader entry-size lump-ints entries]
   (if (empty? lump-ints)
     entries
     (recur reader
            entry-size
            (drop entry-size lump-ints)
            (concat entries (list (reader lump-ints)))))))


(defn read-lump [hexstring directory-entry]
  "Reads the hexstring for a lump given a directory entry."
  (let [hs (take (* 2 (:size directory-entry))
                 (drop (* 2 (:offset directory-entry)) (clean-hexstring hexstring)))
        lump-ints (hexstring-to-ints hs)
        lump-name (re-find #"^[A-Z0-9]*" (:name directory-entry))
        ]
    (case lump-name
      "THINGS" (parse-entries read-thing 10 lump-ints)
      "LINEDEFS" (parse-entries read-linedef 14 lump-ints)
      "SIDEDEFS" (parse-entries read-sidedef 30 lump-ints)
      "VERTEXES" (parse-entries read-vertex 4 lump-ints)
      "SEGS" "SEGS not implemented."
      "SSECTORS" "SSECTORS not implemented."
      "NODES" "NODES not implemented."
      "SECTORS" (parse-entries read-sector 26 lump-ints)
      "REJECT" "REJECT not implemented."
      "BLOCKMAP" "BLOCKMAP not implemented."
      "BEHAVIOR" "BEHAVIOR not implemented."
      (str "Unrecognized lump type: " lump-name)
      )
    ))
